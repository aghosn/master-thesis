% Chapter 3

\chapter{OSR in RJIT} % Main chapter title

\label{Chapter4} % For referencing the chapter elsewhere, use \ref{Chapter2} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------
\section{Overview}
\subsection{Justification}

REWRITE - REFORMULATE.\\
%Goal of the thesis 
    %on stack replacement general mechanism, reusable, at llvm level
    %Why? improve performance and allow greater flexibility in RJIT
        %R is slow, 
        %R is a dynamic language lots of difficulties for implement opt
        %Hence OSR. 
%Reuse an existing library to focus on deoptimization
    %Our goal is to aggressively optimize while preserving correctness
    %Project still young, don't know exactly what we need, don't have feedback on the code
    %Hence better to reuse lib that we can modifiy -> OSR Kit 
%Restate goals 
    %Try to specialise the OSR Kit for the deopt and overcome the limitations. 
    %Will test it with an inlining. 
            

The goal of this Master Thesis project is to provide a flexible OSR deoptimization framework in LLVM, and use it to improve performances in RJIT, our LLVM JIT compiler for R.
R is a programming language and software environment for the statistical computing and graphics, developed by the R Foundation for Statistical Computing\cite{RURL}.
Due to SAY WHYYYYYYYYYYYYYYYYYYYYYYYYYY OOOOOHHHHH GOOOOOOODDDDDD WHHHYYYYYYYYYY, R exhibits very poor performances CITE SOMETHING.
The RJIT project strives to improve these performances by providing a LLVM based JIT compiler for R. SAY MORE.
The RJIT compiler is still pretty young, only a few months old.
As a result, we lack FEEDBACK; DONT KNOW EXACTLY HOW TO IMPROVE PERF AND NEED TO EXPERIMENT.
Therefore, we are looking for a flexible and extensible OSR mechanism that enables us to prototype and experiment various solutions, without trapping ourselves into a single model.\\

The OSR Kit library\cite{OSRKit} is a flexible implementation of on-stack replacement instrumentation in LLVM.
The source-code for the library is available on Github\cite{OSRKitGit}, and the library can be used in any LLVM project by simply copy-pasting the OSR Kit files inside of it.
The simple integration, the availability of the source code, and the flexibility of the framework make it a perfect base implementation upon which we can implement our support for OSR deoptimization mechanisms in RJIT.\\

OSR Kit library enables to work at the LLVM IR level.
LLVM IR is a stable representation that combines the advantages of both the high-level representation, i.e., it still contains some semantic constructions particular to the language being compiled, and the advantages of a lower level representation, closer to the execution engine.
In the case of this master thesis project, i.e., providing OSR mechanisms in the RJIT project, the LLVM IR is the exact middle layer representation that we need. 
At the LLVM IR level, the R semantics are still visible and it therefore allows us to efficiently implement our optimizations.\\

%TODO MORE ABOUT THE FOCUS ON DEOPT. 
MOVE UP\\

This master project thesis focuses on the design and implementation of a prototype for OSR deoptimization support in RJIT.
Starting a new OSR transition implementation from scratch requires time.
Using a flexible and modifiable OSR transition library therefore seemed like the goto option.
We do not waste time reimplementing something that already exists, and can therefore put all our efforts into implementing an interesting OSR deoptimization case, testing it, and extending the OSR Kit library with mechanisms that are specific to our needs (Sections \ref{osrForUs} and \ref{extendingOSR}).\\

\subsection{Limitations}
%While very flexible, comes short on several points
    %Open OSR, not really fitting our case.
    %Continuation style is fine for optimization, but pretty bad for deopt.
        %no replacement when exits... 
        %many clones ... 
        %As we'll see later, cloning is not sufficient ...
While very flexible, the OSR Kit\cite{OSRKit} library presents several disadvantages and exhibits costly behaviors that do not perfectly fit the deoptimization process.
The main advantage of the open OSR is to leverage profiled-guided compilation strategies to generate efficient code.
However, generating a transformation that removes optimizations is hard and does not play well with the OSR Kit instrumentation.
Such a transformation needs to take into account other optimizations that might have been performed on the code after the optimization was applied, i.e., deoptimizing requires to keep track of which transformations performed on the code depend on this optimization, and undo them.
Moreover, the deoptimization case is used to preserve correctness in the program and must be conservative. 
Performance is a soft issue, and hence leveraging profiled-guided compilation strategies is not our main objective. 
For the OSR point, the framework relies on a StateMap that matches values in the from and the continuation functions.
That implies that, in order to generate the continuation function on the fly for the deoptimization case, one is required to 1) be able to reverse an optimization, that might have interfered with other optimizations, and 2) to generate a correct StateMap to give as input to the OSR Kit machinery.\\

Once an OSR exit is taken, it is more likely to be fired in subsequent calls.
For example, in the case of call site inlining, the OSR exit is fired when the inlined function is redefined.
In subsequent calls, the OSR exit will also be triggered.
As a result, if the OSR exit is an open OSR point, the framework will have to perform expensive operations to generate the correct continuation function every time the OSR exit is triggered.
In the light of these observations, we can conclude that the open OSR design does not fit well the deoptimization case.\\

The resolved OSR corresponds to our requirements for deoptimization.
The optimized version is generated from a base function.
Since OSR points are barriers for subsequent optimizations, i.e., they cannot be tempered with, the mapping between the OSR exit and the base function is guaranteed to be preserved, regardless of the subsequent optimizations performed on the optimized function.
It therefore makes sense to instrument the base function to generate a continuation function for the OSR exit.\\

The OSR Kit way of generating the continuation function is expensive.
In the deoptimization case, inserting an OSR exit requires to 1) clone the base function in order to obtain two copies: one is kept as is, the other will be optimized, 2) generate the continuation function. 
Since the continuation function might have a different signature than the base function, the framework has to generate a clone of the body of the base function that will be instrumented with the OSR ENTRY block.
Moreover, in RJIT, cloning a function is not sufficient.
The LLVM IR attributes\cite{llvmAttribute} associated to the RJIT LLVM IR are used to generate safepoints for call stubs and the garbage collector.
For example, when a call stub is inserted inside a function, a patchpoint identified by a unique id is inserted as an LLVM attribute in the corresponding call instruction, and registered inside the framework as a patchpoint that needs special instrumentation in the final compilation steps.
If not properly set, the call stub will not be resolved at run time and yields unexpected behaviors, e.g., a function call that, instead of being evaluated will return its abstract syntax tree(AST).
Therefore, for every clone, we need to go through the IR and fix the attributes, which makes the OSR instrumentation even more expensive.\\

Finally, as it was the case for the open OSR, the resolved OSR does not take into account the fact that an OSR exit might be triggered at every call, once it has been fired a first time.
Although less expensive than the open OSR, a resolved OSR exit that fires at every execution adds the cost of a function call and return, compared to the base function.
The OSR Kit framework does not provide the mechanisms required to avoid this extra cost.\\

\section{OSR RJIT mechanisms}
\subsection{OSR Handler}
%simplified points
%Keeps track of versions, statemaps etc
%Unables to have a less naive usage of the OSR Kit library
%Talk about the base, toInstrument and Exit versions
%Talk about the patchpoints that are fixed automatically
\subsection{Improving the Exit}
%Put the proper exit ! improve the perf
    %Not rely on compensation code because does not relate to local values per see. Hence we modify the framework to do it for us. We know it is the first block, we just insert before the branch instruction. 
    
\subsubsection{Fixing the continuation function}
%deoptimization improving the performances.
    %replace with the function that is not doing the optimization
    %e.g., inlining
    %OSRHandler two attributes.
\subsection{Transitive StateMaps}
%Trying to improve the field of possibilities
    %Chain of statemaps, can find what is in common in both of them
    %Why interesting? Will be able, if provides interface, to enlarge the scope of intermixing optimizations 
\subsection{On the fly compilation}

\subsection{Future work}
%An optimization process? 

