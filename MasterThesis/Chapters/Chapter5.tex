% Chapter 5

\chapter{Case Study: An R Inliner} % Main chapter title

\label{Chapter5} % For referencing the chapter elsewhere, use \ref{Chapter2} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------
This Chapter presents an implementation of a speculative inliner tool, implemented inside the RJIT compiler, that relies on OSR exits to preserve the program's correctness.
We first describe the inliner's implementation.
We then rely on this implementation to test the performances of the main features provided by OSR RJIT.\\

\section{A speculative inliner for RJIT}
\subsection{Justification}
%Dynamic language R 
%function's can be redefined in R, need the OSR typical static opt that is not possible in R
%Used in other papers.
%interesting because implies that we need to clone IR -> put some pressure on our additions.
R is a dynamic language. 
Dynamic programming languages have the particularity to perform, at runtime, common programming behaviors executed during the compilation in static programming languages.
Extending the program, adding code, extending objects and definitions, type setting or modifying the type system are such behaviors that, in dynamic programming languages, can take place at runtime.
These particularities make certain common static compilation optimizations hard to implement in a dynamic programming language.
One example of such optimization is inlining (i.e., inline expansion), that replaces a function call site with the body of the function called.\\

Chapter \ref{Chapter2} presents the on-stack replacement(OSR) mechanism.
The OSR techniques enable to implement \textit{speculative} optimizations, i.e., to transform a function based on the assumption that the result of the transformation will be correct and improve the program's performance at runtime.
If the assumption fails, the OSR mechanisms preserve correctness in the program.
Thanks to this versatile tool, static programming languages optimizations can be performed speculatively in a compiler for a dynamic programming language.\\

In R, and more specifically in RJIT, inlining functions is hard. 
An R function is wrapped in a closure, and might be redefined at any time during the program's execution.
As a result, the only viable way of allowing function inlining in RJIT is to rely on OSR mechanisms.\\

Inlining is an interesting optimization, and its impact on the code performance is hard to predict. 
It holds an important trade-off between time and space, i.e., how much improvement in terms of speed can be obtained, at the cost of some extra space.
Furthermore, excessive inlining might increase register pressure and deplete the instruction cache, therefore decreasing the speed of the program's execution.
Finally, inlining can be viewed as a first step toward other optimizations.
Copying a function's body at its call site enables to enlarge the scope considered by the compiler, and might therefore uncover new opportunities for optimizations.\\

Apart from being a viable OSR-based speculative optimization in RJIT, inlining allows to put some pressure on the OSR Handler's mechanisms.
First, as explained in Chapter \ref{Chapter4New}, the OSR mechanism requires to obtain fresh clones of functions bodies via the OSR Handler's functions.
Second, in order to inline a function call, a copy of the callee's body needs to be obtained.
This body, in RJIT OSR, can be obtained through the OSR Handler API.
Function inlining might further force AOT compilation of the inlined functions, hence enabling us to test every aspect of the functionalities provided by the OSR Handler.\\

RJIT does not gather profiling information that enable to identify good targets for inlining.
This is, however, far from being a limitation.
On the contrary, it is a perfect case study for OSR mechanisms in R.
Although inlining function calls in R produces unsound compiled code, the OSR mechanism enables to ensure that the program is correct.
As explained in Section \ref{justificationgoals}, R performance bottlenecks are consequences of the language semantics.
In the future, the OSR mechanism is destined to enable to break R semantics, and to produce unsound, highly optimized code.
Profiling will give insights on whether or not the program might benefit from such optimizations, but is not expected to be able to ensure that any of these transformations is sound.
Not relying on a profiler and blindly inlining function calls, whenever it is possible, shows how much flexibility this OSR implementation truly brings to RJIT.\\ 

\subsection{Challenges}
%Function Calls -> how to identify them
%Resolving the function
%Continuation function problem
%IR fresh + AOT behavior
%TODO ENVIRONMENT !!!!!!!!
An OSR-based speculative inliner for RJIT needs to be implemented at the LLVM IR level.
This requires to be able to identify function calls inside the LLVM IR, extract the callee's SEXP from the environment, and perform the appropriated transformations on the IR.
While relatively simple conceptually, implementing such a mechanism presents several challenges in RJIT.\\

An R function call corresponds to several instructions in the RJIT LLVM IR.
First, a call to the \textit{getFunction} intrinsic is inserted.
The call takes as parameter the AST of the call, stored in the constant pool associated to the function SEXP.
This intrinsic enables to resolve, at runtime, the callee. 
To do so it explores the current environment.
If no match is found, it accesses the enclosing environments until either reaching a definition or triggering an error letting the user know that the callee could not be found.
The compiler then emits instructions to load arguments to the function call.
Finally, an ic stub is generated. 
The ic stub takes as arguments the result of the call to the \textit{getFunction} intrinsic, the arguments provided to the call, a pointer to the caller, the current constant pool, and the environment.
When executed once, the ic stub replaces itself with a call to an inlined cached wrapper function dedicated to the callee.
Figure \ref{fig:functioncall} provides a simple R function that performs a function call, and the equivalent LLVM IR generated by RJIT.\\

In the OSR inliner, function calls can be identified by looking for ic stubs.
The OSR inliner has to run on non-instrumented LLVM IR. 
The ic stubs have not yet been replaced by inlined cached wrappers.
Therefore, even though a function call is compiled into several instructions, ic stubs and their arguments are enough to obtain all the information corresponding to a function call.\\

\begin{figure}[h]
\includecode{Code/functionCall.c}
\caption{Example of RJIT LLVM IR for a function call.}
\label{fig:functioncall}
\end{figure}


The OSR inliner needs to obtain a clone of the callee's LLVM IR, in order to inline a function call.
If the callee was never compiled before, the \textit{getFreshIR} function will trigger an AOT compilation of the function.
Since the OSR inliner heavily relies on fresh IR, one challenge is to try to minimize the amount of cloning required in order to perform the transformations.\\

Inlining in R requires to create a dedicated environment for the inlined function.
Implementing a sound name mangler in R is hard. 
It requires to check that fresh names do not collide with parent or child environments.
Furthermore, replacing arguments with their actual values is not semantically correct, due to the way promises are evaluated.
For these reasons, creating a dedicated environment appears to be the only sound solution.\\

The OSR Kit mechanism requires to associate a \textit{toInstrument} clone to every function transformed.
The continuation function has to be a clone of the base function used to generate the optimized one.
One challenge is to carefully implement the inlining in order to limit the number of \textit{toInstrument} functions generated.\\

Finally, all the challenges related to the cloned and continuation functions mentioned in Section \ref{additionalchallenges} need to be considered.
Fixing the LLVM IR requires to go through every instruction in the cloned functions.
As a result, in order to save compilation time, it is important to perform such operations only when they are truly needed.\\

\subsection{Implementation}
%FunctionCall to abstract away the call
%The different mods for inlining.
%The algorithm to inline.
MORE MODES OF EXECUTION !!!!!\\

This section describes the implementation of the OSR inliner.
The OSR inliner relies on a special C++ class, called \textit{FunctionCall}, to extract function calls in the LLVM IR and easily access its elements. 
The OSR inliner also provides different modes, that enables more or less aggressive speculative inlining.\\

The FunctionCall class provides a static function, called \textit{getFunctionCalls}, that takes an LLVM IR as input, and extracts the function calls it contains.
For each ic stub call, the function creates an instance of the FunctionCall class. 
A FunctionCall object gives quick access to each element of the function call, i.e., the result of the \textit{getFunction} call, the arguments to the call, and the additional elements of the ic stub call.
The \textit{getFunctionCalls} returns a list of FunctionCall instances.
It is important to note that, for efficiency and better integration, the \textit{getFunctionCalls}, or any similar function that needs to go through the LLVM IR instructions and match a specific pattern, will be able to rely on the pass \& match mechanism being developed in RJIT.
RJIT provides a special matcher mechanism, combined to the LLVM passes implementation, that enables to extract special patterns from the LLVM IR.
One of its main goals is to reduce the number of iterations on the entire LLVM IR, by merging different passes.
Unfortunately, this feature was not yet ready at the time at which the RJIT OSR project was implemented.\\

The OSR inliner algortihm is a very basic, aggressive, speculative inliner. 
RJIT does not have a profiler or a static analyzer yet.
As a result, the OSR inliner cannot rely on any extra information to decide if a call should be inlined or not.
The OSR inliner proposes different modes of execution, that enable more or less aggressive inlining techniques.
The default mode of execution inlines all the calls inside the current function, as long as a body can be obtained for the callee.
The OSR inliner does not inline recursive calls.
A more agressive mode, called \textit{all inline}, enables to recursively apply the OSR inliner on the body of the functions being inlined.
Function calls that contain ellipsis, missing, or named arguments are not inlined by the OSR Inliner.
\\


The OSR inliner implements a very naive inlining algorithm.
All functions calls are extracted from the outer function using the \textit{getFunctionCalls} function.
The OSR Inliner then traverses the list of function calls, and groups them by call targets.
The callee's closure can be obtained by looking up the symbol of the function call in the outer function's environment.
In the \textit{all inline} mode, the OSR inliner generates a fully inlined LLVM IR for each different callee, i.e., it inlines all the calls inside each compiled callee. 
In the default mode, the OSR inliner simply calls the getFreshIR method to obtain the callee's LLVM IR.
The OSR inliner creates the toInstrument clone of the outer function.
The toInstrument will be used as to create the continuation function for each OSR exit inserted in the outer function.
It is wrapped in a valid function SEXP, added to the module, and has a valid IR.
Then, for each different callee, the OSR inliner proceeds as follows: 
\begin{enumerate}
    \item In the body of the callee, update accesses to the constant pool by changing the index to $\text{LENGHT}(\text{CP}_{\text{outer}} + \text{index})$.
    \item Append the callee's constant pool to the outer function's one.
    \item For each function call to the callee:
        \begin{enumerate}
            \item Obtain an unused clone of the callee.
            \item Insert instructions to create a new environment that contains the correct arguments to values mapping, before the ic stub.\label{step:newrho}
            \item Replace all accesses to the environment, i.e., rho argument, in the callee's body by the newly created environment.
            \item Move the callee's body inside the outer function, after the instruction of step \ref{step:newrho}.
            \item Remove the ic stub.
            \item Call the insertOSRExit with the outer function as the from function, the toInstrument as the continuation function, instructions that compare the result of the \textit{getFunction} call with the hard coded address of the callee's closure as the OSR condition, and the \textit{constant} call as the transition point, i.e., the instruction that was directly above the ic stub in the original outer function.
        \end{enumerate}
\end{enumerate}

Once every call has been inlined, the OSR inliner calls the \textit{resetSafePoint} on the outer function, sets its function SEXP inside the corresponding closure and returns.
It is important to note that the OSR inliner forces the compilation of every callee. 
As a result, any function contained in the outer function, and inlined, will also be compiled. 
When in the \textit{all inline} mode, they are also fully inlined.
Any subsequent call to a callee will therefore benefit from either a fully compiled, or a fully inlined and compiled version of the function.\\

The continuation function for an OSR exit corresponds to the fully unoptimized base function. 
The toInstrument function is used to generate the continuation function and does not contain any inlined call.
This enables to limit the number of toInstrument functions generated during the transformation of the outer function.
Furthermore, it provides the guarantee that OSR exits will not be triggered in cascade.
A more optimized solution would be to generate on the fly the continuation function, and inline all the calls in it whenever possible.\\

The OSR Inliner provides a compensation code generator mechanism. 
The compensation code is a simple call to a C++ function, that takes as argument an integer identifier.
The identifier corresponds to a function SEXP containing the toInstrument version.
The C++ function uses the identifier to retrieve the toInstrument function SEXP, and replaces the invalidated function in the closure with this SEXP.\\

CODE EXAMPLE OF INLINING, TOINSTRUMENT AND CONT.\\

\section{Tests}
\subsection{GNUR RJIT vs. Inlining on Shootout benchmarks}

\subsubsection{General execution comparison}
\subsubsection{Cost of default mode vs. regular compilation}
\subsubsection{Cost of all inline mode vs. regular compilation}
\subsection{OSR Exit vs. Replacing the closure}

\subsection{OSR Handler getFreshIR vs. Always recompiling}
%Intro

%One execution is more expensive, so need to test fully generated.
%Overhead 
%Fully generated
The OSRHandler \textit{getFreshIR} function is designed to provide quick access to non-instrumented LLVM IR, and avoid recompiling a function every time the IR is needed.
Reusing LLVM IR across different modules, however, requires to adapt the cloned IR.
As a result, we evaluate the efficiency of the \textit{getFreshIR} function by comparing its performance to the basic compilation.\\

During a single compilation pass, the \textit{getFreshIR} function is expected to be less efficient than simply compiling the function SEXP.
In fact, for a function SEXP that was never compiled, the getFreshIR function needs to go through the entire compilation of the function, in addition to generating the correct entries in the base version map.
We evaluate the overhead of the getFreshIR method compared to the simple compilation.
In order to do so, we call the getFreshIR and the jit.compile on every function defined in the benchmark files.
The result of this experiment is provided in FIGURE REF.\\

COMMENT ON RESULTS.\\


To evaluate the potential of the getFreshIR function, the base version map needs to be fully generated.
The OSR Handler performs extra work during the first compilation of a function, in order to save execution time for a later pass on the function. 
As a result, we provide a second experimentation in which the base version is fully generated.
We then call the getFreshIR and fix the IR REFORMULATE 10 times per function contained in a benchmark. 
We compare the performance obtained with a complete recompilation of the function.
The results are presented in FIGURE REF.\\


COMMENT ON RESULTS.\\


