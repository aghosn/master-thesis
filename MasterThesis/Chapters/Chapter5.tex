% Chapter 5

\chapter{Case Study: An R Inliner} % Main chapter title

\label{Chapter5} % For referencing the chapter elsewhere, use \ref{Chapter2} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------
This Chapter presents an implementation of a speculative inliner tool, implemented inside the RJIT compiler, that relies on OSR exits to preserve the program's correctness.
We first describe the inliner's implementation.
We then rely on this implementation to test the performances of the main features provided by the OSR implementation in RJIT.\\

\section{A speculative inliner for RJIT}
\subsection{Justification}
%Dynamic language R 
%function's can be redefined in R, need the OSR typical static opt that is not possible in R
%Used in other papers.
%interesting because implies that we need to clone IR -> put some pressure on our additions.
R is a dynamic language. 
Dynamic programming languages have the particularity to perform, at runtime, common programming behaviors executed during the compilation in static programming languages.
Extending the program, adding code, extending objects and definitions, type setting or modifying the type system are such behaviors that, in dynamic programming languages, can take place at runtime.
These particularities make certain common static compilation optimizations hard to implement in a dynamic programming language.
One example of such optimization is inlining (i.e., inline expansion), that replaces a function call site with the body of the called function.\\

Chapter \ref{Chapter2} presents the on-stack replacement(OSR) mechanism.
The OSR techniques enable to implement \textit{speculative} optimizations, i.e., to transform a function based on the assumption that the result of the transformation will be correct and improve the program's performances at runtime.
If the assumption fails, the OSR mechanisms preserve correctness in the program.
Thanks to this versatile tool, static programming languages optimizations can be performed speculatively in a compiler for a dynamic programming language.\\

In R, and more specifically in RJIT, inlining functions is hard. 
An R function is wrapped in a closure, and might be redefined at any time during the program's execution.
As a result, the only viable way of allowing function inlining in RJIT is to rely on OSR mechanisms.\\

Inlining is an interesting optimization, and its impact on the code performance is hard to predict. 
It holds an important trade-off between time and space, i.e., how much improvement in terms of speed can be obtain, at the cost of some extra space.
Furthermore, excessive inlining might increase register pressure and deplete the instruction cache, therefore decreasing the speed of the program's execution.
Finally, inlining can be viewed as a first step toward other optimizations.
Copying a function's body at its call site enables to enlarge the scope considered by the compiler, and might therefore uncover new opportunities for optimizations.\\

Apart from being a viable OSR-based speculative optimization in RJIT, inlining allows to put some pressure on the OSR Handler's mechanisms.
First, as explained in Chapter \ref{Chapter4New}, the OSR mechanism requires to obtain fresh clones of functions bodies via the OSR Handler's functions.
Second, in order to inline a function call, a copy of the callee's body needs to be obtained.
This body, in RJIT OSR, can be obtained through the OSR Handler API.
Function inlining might further force AOT compilation of the inlined functions, hence enabling us to test every aspect of the functionalities provided by the OSR Handler.\\

USED IN OTHER PAPERS\\


\subsection{Challenges}
%Function Calls -> how to identify them
%Resolving the function
%Continuation function problem
%IR fresh + AOT behavior
%TODO ENVIRONMENT !!!!!!!!
An OSR-based speculative inliner for RJIT needs to be implemented at the LLVM IR level.
This requires to be able to identify function calls inside the LLVM IR, extract the callee's SEXP from the environment, and perform the appropriated transformations on the IR.
While relatively simple conceptually, implementing such a mechanism presents several challenges in RJIT.\\

An R function call corresponds to several instructions in the RJIT LLVM IR.
First, a call to the \textit{getFunction} intrinsic is inserted.
The call takes as parameter the AST of the call, stored in the constant pool associated to the function SEXP.
This intrinsic enables to resolve, at runtime, the callee. 
To do so it explores the current environment.
If no match is found, it accesses the enclosing environments until either reaching a definition or triggering an error letting the user know that the callee could not be found.
The compiler then emits instructions to load arguments to the function call.
Finally, an ic stub is generated. 
The ic stub takes as arguments the result of the call to the \textit{getFunction} intrinsic, the arguments provided to the call, a pointer to the caller, the current constant pool, and the environment.
When executed once, the ic stub replaces itself with a call to a inlined cached wrapper function dedicated to the callee.\\

In the OSR inliner, function calls can be identified by looking for ic stubs.
The OSR inliner has to run on non-instrumented LLVM IR. 
The ic stubs have not yet been replaced by inlined cached wrappers.
Therefore, even though a function call is compiled into several instructions, ic stubs and their arguments are enough to obtain all the information corresponding to a function call.\\

EXAMPLE FUNCTION CALL\\

In order to inline a function call, the OSR inliner needs to obtain a clone of the callee's LLVM IR.
If the callee was never compiled before, the \textit{getFreshIR} function will trigger an AOT compilation of the function.
Since the OSR inliner heavily relies on fresh IR, one challenge is to try to minimize the amount of cloning required in order to perform the transformations.\\

TODO CREATE NEW RHO\\

The OSR Kit mechanism requires to generate a \textit{toInstrument} clone per function call inlined.
The continuation function has to be a clone of the base function used to generate the optimized one.
One challenge is to carefully implement the inlining in order to limit the number of \textit{toInstrument} functions generated.\\

Finally, all the challenges related to the cloned and continuation functions mentioned in Section \ref{additionalchallenges} need to be considered.
Fixing the LLVM IR requires to go through every instruction in the cloned functions.
As a result, in order to save compilation time, it is important to perform such operations only when they are truly needed.\\

\subsection{Implementation}
%FunctionCall to abstract away the call
%The different mods for inlining.
%The algorithm to inline.
This section describes the implementation of the OSR inliner.
The OSR inliner relies on a special C++ class, called \textit{FunctionCall}, to extract function calls in the LLVM IR and easily access its elements. 
The OSR inliner also provides different mods, that enables more or less aggressive speculative inlining.\\

The FunctionCall class provides a static function, called \textit{getFunctionCalls}, that takes an LLVM IR as input, and extracts the function calls it contains.
For each ic stub call, the function creates an instance of the FunctionCall class. 
A FunctionCall object gives quick access to each element of the function call, i.e., the result of the \textit{getFunction} call, the arguments to the call, and the additional elements of the ic stub call.
The \textit{getFunctionCalls} returns a list a list of FunctionCall instances.
It is important to note that, for efficiency and better integration, the \textit{getFunctionCalls}, or any similar function that needs to go through the LLVM IR instructions and match a specific pattern, will be able to rely on the pass \& match mechanism being developed in RJIT.
RJIT provides a special matcher mechanism, combined to the LLVM passes implementation, that enables to extract special patterns from the LLVM IR.
One of its main benefits is to reduce the number of iterations on the entire LLVM IR.
Unfortunately, this feature was not yet ready at the time at which the RJIT OSR project was implemented.\\

The OSR inliner algortihm is a very basic, aggressive, speculative inliner. 
RJIT does not have a profiler or a static analyzer yet.
As a result, the OSR inliner cannot rely on any extra information to decide if a call should be inlined or not.
The OSR inliner, however, proposes different mods of execution, that enable more or less aggressive inlining techniques.
The default mod of execution inlines all the calls inside the current function, as long as a body can be obtained for the callee.
The OSR inliner does not inline recursive calls.
A more agressive mod, called \textit{all inline}, enables to recursively apply the OSR inliner on the body of the functions being inlined.
\\

The OSR inliner implements a very naive inlining algorithm.
The copy of the function in which we inline the calls is called the \textit{working copy}.
Function calls are extracted by calling the \textit{getFunctionCalls}.
TODO FUNCTION CALLS SAME TARGET, GROUPED TOGETHER?.
For each function call, the symbol accessed by the \textit{getFunction} call is extracted from the constant pool associated with the function.
A GNUR function, that takes as parameters a symbol and an environment, enables to access the corresponding closure.
If a closure is found, the default mod calls \textit{getFreshIR} on the closure to obtain the a clone of the code to inline.
If the OSR inliner runs in the \textit{all inline} mod, it needs to obtain a fully inlined version of the function.
To do this, it runs the OSR inliner on the resolved closure.
In order to save compilation time, it caches the result of the inlining into a local map.
This makes sense since, in one run of the inliner, all the function call targets are constant, i.e., no function can be redefined.
The inliner then proceeds as follows for each function call:\\

MODIFY IF INLINING ALL CALL SITES\\
\begin{enumerate}
    \item A toInstrument clone of the working copy is made. It is used to create the OSR exit continuation functions.
    \item Instructions to create a new environment for the inlined function are inserted after the ic stub, in the working copy.\label{rho}
    \item All accesses to the constant pool inside the body of the callee are modified to access new indices, computed as $\text{LENGHT}(\text{CP}_{\text{outer}}) + \text{index}$.
    \item The constant pool argument in the body of the callee is replaced with the constant pool of the outer function.
    \item The environment argument in the body of the callee is replaced with the new environment created in step \ref{rho}.
    \item The body of the callee is added after the instructions inserted in step \ref{rho}.
    \item The ic stub call is removed.
    \item The insertOSRExit function is called with the working copy as the from function, the toInstrument as the continuation function, a comparison between the result the \textit{getFunction} call and the address of the closure inlined as the OSR condition, and the \textit{constant} call as the transition point.
    \item The \textit{resetSafepoints} function is called on the working copy to fix its IR.
    \item The constant pool of the copy is appended to the constant pool of the working copy.
\end{enumerate}


\section{Tests}
\subsection{GNUR RJIT vs. Inlining on shootout}
\subsection{OSR Exit vs. Replacing the closure}
\subsection{OSR Handler getFreshIR vs. Always recompiling}


