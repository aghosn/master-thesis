% Chapter 1

\chapter{Introduction} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------

Interpreted dynamic languages, such as JavaScript, Ruby, Python or R, often suffer from poorer performances than statically compiled and typed languages, like C.
This disparity has multiple factors, among which the execution at runtime of many common programming behaviors, e.g., typing and optimizations, that static programming languages perform during compilation.
In order to improve interpreted languages performance, just-in-time (JIT) compilers started to appear.
Since in interpreted languages, little is known about the program ahead of time, a JIT compiler relies on runtime profiling data to perform adaptative optimizations and generate efficient compiled code at runtime.
The set of optimizations enabled in a JIT compiler are often more restricted than in a static compiler, where the entire program is available during the compilation.
For example, in a static compiler, function $g$ in Figure \ref{fig:example} can be type-checked, $H$ and $f$ are known and their calls can be inlined and optimized.
In a dynamic language, $H$ and $f$ might not be yet defined or can be modified, their types are unknown, and no optimization can be performed.
As a result, new techniques are needed to lift restrictions in JIT compilers, and enable more agressive, speculative optimizations.\\

\begin{figure}[h]
\includecode{Code/Example.cpp}
\caption{Example.}
\label{fig:example}
\end{figure}

On-stack replacement (OSR) is a concept that consists in replacing a program that is currently executing, by another potentially completely different program, while preserving the execution state.
Being able to switch between different programs, at runtime, while preserving the progress made so far by the execution, enables to implement aggressive speculative optimizations in JIT compilers.
The lack of information about the program's content is compensated by allowing the compiler to assume something about the program, and perform optimizations based on this assumption.
Whenever the assumption fails at runtime, the invalidated compiled program is replaced by a correct version, which resumes the execution.\\

\begin{wrapfigure}[12]{l}{6.5cm}
\includecode{Code/Example2.cpp}
\caption{Optimized versions.}
\end{wrapfigure}
Using OSR, a JIT compiler can assume that $H$ will not be redefined, and inline it during the JIT compilation of $g$.
It can further resolve $p$ and $y$, type-check them, and optimize the computation of $t * (3 ^ 4)$.
Whenever the assumption fails, e.g., $f$ triggers a redefinition of $H$, OSR allows to stop the execution of the program between lines 9 and 10, extract the state, and replace the function with the unsugared version.
The execution resumes at line 9 in Figure \ref{fig:example}.
On-stack replacement implementations are state-of-the-art features in advanced virtual machines and JIT compilers.\\


The R programming language suffers from very poor performances. 
It further exhibits a lazy evaluation of dynamically typed elements which prevent many common compiler optimizations from being performed.
Even worse, performance bottlenecks in R are intimately linked to R semantics. 
A JIT compiler for R, equipped with an efficient OSR implementation, could lift up such restrictions.
The focus of this thesis is to provide an OSR implementation in RJIT, a JIT compiler for R, that enables to perform speculative optimizations while preserving the correctness of the program's execution.
The next section gives an overview of our solution and its implementation.\\

\section{Proposed Solution}
%First is overview of OSR implementations
%Second OSR deoptimization for RJIT compiler
%Third a speculative inliner to test the design
The first contribution of this thesis is an overview and synthesis of existing on-stack replacement implementations.
This thesis describes in details the main approaches taken to implement OSR, and their advantages and drawbacks.\\

The second and main contribution of this thesis is the implementation of OSR RJIT, an efficient OSR mechanism in the RJIT compiler for R, that enables agressive speculative optimizations while preserving the correctness of the program.
The implementation focuses on the on-stack replacement deoptimization mechanism in RJIT, and strives to provide code instrumentation with as little overhead as possible.
OSR RJIT prototypes a mechanism that could, in the future, enable to remove performance bottlenecks that are specific to R semantics.\\

The third and final contribution of this thesis is the implementation of an OSR-based speculative inliner in RJIT.
Function call inlining presents an interesting challenge in R, that requires to consider most of R and RJIT specificities.
The OSR inliner is used to evaluate our OSR implementation and provides an example of an interesting use of the OSR concept in an R compiler.\\

\section{Paper Overview}

The rest of this thesis is organized as follows: Chapter \ref{Chapter2} provides an overview of the on-stack replacement concept, defines OSR related vocabulary, and gives a high-level description of OSR mechanisms.
Chapter \ref{Chapter3} presents related work, i.e., implementations of OSR mechanisms in different virtual machines. It also provides a classification summary that regroups the differences between each implementation.
Chapter \ref{Chapter4New} OSR RJIT, the implementation of efficient OSR deoptimization in the RJIT compiler for R.
Chapter \ref{Chapter5} presents experimental results obtain with a speculative inliner, based on OSR RJIT mechanisms.
Finally, Chapter \ref{Chapter6} concludes and presents ideas for future work.\\ 





