% Chapter 1

\chapter{Introduction} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------

Interpreted dynamic languages, such as JavaScript, Ruby, Python or R, often suffer from poorer performances than statically compiled and typed languages, like C.
This disparity has multiple factors, among which the execution at runtime of many common programming behaviors, e.g., typing and optimizations, that static programming languages perform during compilation.
In order to improve interpreted languages performance, just-in-time (JIT) compilers started to appear.
Since in interpreted languages, little is known about the program ahead of time, a JIT compiler relies on runtime profiling data to perform adaptative optimizations and generate efficient compiled code at runtime.
The set of optimizations enabled in a JIT compiler are often more restricted than in a static compiler, where the entire program is available during the compilation.
For example, in a static compiler, function $g$ in FIGURE REF can be type-checked, $H$ and $f$ are known and their calls can be inlined and optimized.
In a dynamic language, $H$ and $f$ might not be yet defined or can be modified, their types are unknown, and no optimization can performed.
As a result, new techniques are needed to lift restrictions in JIT compilers, and enable more agressive, speculative optimizations.\\

%\begin{wrapfigure}[11]{l}{6.5cm}
\includecode{Code/Example.cpp}
%\end{wrapfigure}

On-stack replacement (OSR) is a concept that consists in replacing a program that is currently executing, by another potentially completely different program, while preserving the execution state.
Being able to switch between different programs, at runtime, while preserving the progress made so far by the execution, enables to implement aggressive speculative optimizations in JIT compilers.
The lack of information about the program's content is compensated by allowing the compiler to assume something about the program, and perform optimizations based on this assumption.
Whenever the assumption fails, the invalidated compiled program is replaced by a correct version, which resumes the execution.\\

\begin{wrapfigure}[11]{l}{6.5cm}
\includecode{Code/Example2.cpp}
\end{wrapfigure}
Using OSR, a JIT compiler can assume that $H$ will not be redefined, and inline it during the JIT compilation of $g$.
It can further resolve $p$ and $y$, type-check them, and optimize the computation of $t * (3 ^ 4)$.
Whenever the assumption fails, e.g., $f$ triggers a redefinition of $H$, OSR allows to stop the execution of the program between lines 9 and 10, extract the state, and replace the function with the unsugared version.
The execution resumes at line 9 in FIGURE REF.
On-stack replacement implementations are state-of-the-art features in advanced virtual machines and JIT compilers.\\


The R programming language suffer from very poor performances. 
It further exhibits a lazy evaluation of dynamically typed elements which prevent many common compiler optimizations from being performed.
A JIT compiler for R could therefore benefit from an OSR implementation.
The focus of this thesis is to provide an OSR implementation in RJIT, a JIT compiler for R, that enables to perform speculative optimizations while preserving the correctness of the program's execution.
The next section gives an overview of our solution and its implementation.\\

\section{Proposed Solution}
Description of what I've done.

\section{Paper Overview}
Explain each chapter.